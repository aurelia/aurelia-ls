#!/usr/bin/env node
/**
 * AOT Build Demo
 *
 * Demonstrates the transform package by showing before/after source transformation.
 * This is what happens at compile time: the Vite plugin runs this transformation
 * to inject AOT-compiled definitions directly into TypeScript source.
 *
 * Usage:
 *   node demo.mjs           # Show transformation in console
 *   node demo.mjs --emit    # Also write output files to dist/
 *
 * Output files (with --emit):
 *   dist/my-component.js       - Transformed JavaScript (bundle-ready)
 *   dist/my-component.debug.js - Same with verbose comments for inspection
 *   dist/artifacts.json        - Raw AOT compilation data
 */

import { readFileSync, writeFileSync, mkdirSync } from "fs";
import { resolve, dirname } from "path";
import { fileURLToPath, pathToFileURL } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, "../..");
const distDir = resolve(__dirname, "dist");

// Parse args
const args = process.argv.slice(2);
const shouldEmit = args.includes("--emit") || args.includes("-e");
const quietMode = args.includes("--quiet") || args.includes("-q");

// Import from local packages (use file:// URLs for Windows compatibility)
const ssrPath = pathToFileURL(resolve(rootDir, "packages/ssr/out/index.js")).href;
const transformPath = pathToFileURL(resolve(rootDir, "packages/transform/out/index.js")).href;

const { compileWithAot } = await import(ssrPath);
const { transform } = await import(transformPath);

// =============================================================================
// Demo
// =============================================================================

function log(...args) {
  if (!quietMode) console.log(...args);
}

log("=".repeat(80));
log("AOT BUILD DEMO - Source Transformation");
log("=".repeat(80));
log();

// Read source files
const sourcePath = resolve(__dirname, "my-component.ts");
const templatePath = resolve(__dirname, "my-component.html");

const source = readFileSync(sourcePath, "utf-8");
const template = readFileSync(templatePath, "utf-8");

log("INPUT: my-component.ts");
log("-".repeat(80));
log(source);
log();

log("INPUT: my-component.html");
log("-".repeat(80));
log(template);
log();

// Step 1: Compile the template with AOT
log("STEP 1: Compile template with AOT compiler...");
log("-".repeat(80));

const aot = compileWithAot(template, {
  name: "my-component",
  templatePath,
});

log(`  Target count: ${aot.targetCount}`);
log(`  Expression count: ${aot.raw.codeResult.expressions.length}`);
log(`  Nested templates: ${aot.raw.codeResult.definition.nestedTemplates.length}`);
log();

// Step 2: Transform the source to inject $au (with comments for debug output)
log("STEP 2: Transform source to inject static $au...");
log("-".repeat(80));

const debugResult = transform({
  source,
  filePath: sourcePath,
  aot: aot.raw.codeResult,
  resource: {
    kind: "custom-element",
    name: "my-component",
    className: "MyComponent",
    declarationForm: "decorator",
    bindables: [],
  },
  template: aot.template,
  nestedHtmlTree: aot.raw.nestedHtmlTree,
  removeDecorators: true,
  includeComments: true,
});

// Also generate minified version (no comments)
const minResult = transform({
  source,
  filePath: sourcePath,
  aot: aot.raw.codeResult,
  resource: {
    kind: "custom-element",
    name: "my-component",
    className: "MyComponent",
    declarationForm: "decorator",
    bindables: [],
  },
  template: aot.template,
  nestedHtmlTree: aot.raw.nestedHtmlTree,
  removeDecorators: true,
  includeComments: false,
});

log(`  Edits applied: ${debugResult.edits.length}`);
log(`  Original form: ${debugResult.meta.originalForm}`);
log(`  Expression count: ${debugResult.meta.expressionCount}`);
log(`  Instruction rows: ${debugResult.meta.instructionRowCount}`);
log();

// Show the OUTPUT
log("OUTPUT: Transformed my-component.ts");
log("-".repeat(80));
log(debugResult.code);
log();

// =============================================================================
// File Emission
// =============================================================================

if (shouldEmit) {
  log("=".repeat(80));
  log("EMITTING FILES");
  log("=".repeat(80));
  log();

  // Create dist directory
  mkdirSync(distDir, { recursive: true });

  // Generate bundle-like JavaScript output
  const bundleHeader = `/**
 * AOT-Compiled Component: my-component
 *
 * This file was generated by the Aurelia AOT compiler.
 * It contains pre-compiled template definitions that bypass runtime compilation.
 *
 * Generated: ${new Date().toISOString()}
 */

`;

  // Clean up the transformed code for bundle output:
  // - Remove the template import (template is now inlined in $au)
  // - Remove unused customElement import
  const bundleCode = debugResult.code
    .replace(/import template from ["']\.\/my-component\.html["'];?\n?/g, "")
    .replace(/import \{ customElement \} from ["']aurelia["'];?\n?/g, "");

  const minBundleCode = minResult.code
    .replace(/import template from ["']\.\/my-component\.html["'];?\n?/g, "")
    .replace(/import \{ customElement \} from ["']aurelia["'];?\n?/g, "");

  // Write debug version (with comments)
  const debugPath = resolve(distDir, "my-component.debug.js");
  writeFileSync(debugPath, bundleHeader + bundleCode);
  log(`  Written: dist/my-component.debug.js (${bundleCode.length} bytes)`);

  // Write production version (no comments, more compact)
  const prodPath = resolve(distDir, "my-component.js");
  writeFileSync(prodPath, bundleHeader + minBundleCode);
  log(`  Written: dist/my-component.js (${minBundleCode.length} bytes)`);

  // Write artifacts JSON for inspection
  const artifacts = {
    meta: {
      generated: new Date().toISOString(),
      component: "my-component",
      className: "MyComponent",
    },
    compilation: {
      targetCount: aot.targetCount,
      expressionCount: aot.raw.codeResult.expressions.length,
      nestedTemplates: aot.raw.codeResult.definition.nestedTemplates.length,
    },
    template: {
      original: template,
      compiled: aot.template,
    },
    expressions: aot.raw.codeResult.expressions,
    definition: aot.raw.codeResult.definition,
    nestedHtmlTree: aot.raw.nestedHtmlTree,
  };

  const artifactsPath = resolve(distDir, "artifacts.json");
  writeFileSync(artifactsPath, JSON.stringify(artifacts, null, 2));
  log(`  Written: dist/artifacts.json`);

  log();
  log("Files written to: examples/aot-build/dist/");
  log();
}

if (!shouldEmit) {
  log("Run with --emit to write output files to dist/");
  log();
}
