/**
 * SSR Renderer
 *
 * Renders Aurelia templates to HTML string using the actual Aurelia runtime.
 * This ensures perfect parity with client-side rendering.
 */

import { DI, Registration } from "@aurelia/kernel";
import { Aurelia, IPlatform, StandardConfiguration, ISSRContextToken, SSRContext, CustomElement } from "@aurelia/runtime-html";
import type { IInstruction } from "@aurelia/template-compiler";
import { createServerPlatform, getDocument } from "./platform.js";
import {
  processSSROutput,
  syncPropertiesForSSR,
  type HydrationManifest,
  type SSRProcessOptions,
} from "./ssr-processor.js";

export interface RenderOptions {
  /** Component state */
  state: Record<string, unknown>;

  /**
   * SSR processing options.
   * When provided, enables post-render processing for clean HTML output.
   * The manifest is automatically generated by the runtime during rendering
   * via the SSRContext recording mechanism.
   */
  ssr?: SSRProcessOptions;
}

export interface RenderResult {
  /** Rendered HTML (clean if ssr.stripMarkers=true) */
  html: string;

  /**
   * Hydration manifest (with elementPaths if ssr.stripMarkers=true).
   * Only present when ssr options are provided.
   */
  manifest?: HydrationManifest;
}

export interface ComponentDefinition {
  /** Template HTML string */
  template: string;
  /** Binding instructions for the template */
  instructions: IInstruction[][];
  /** Component name */
  name?: string;
}

/**
 * Render a component to HTML string using the Aurelia runtime.
 *
 * @param definition - The compiled component definition
 * @param options - Render options including state
 * @returns The rendered HTML
 *
 * @example
 * ```typescript
 * const result = await renderToString(
 *   {
 *     template: '<div><!--au:0--></div>',
 *     instructions: [[new TextBindingInstruction('message')]],
 *   },
 *   { state: { message: 'Hello World' } }
 * );
 * console.log(result.html); // '<div><!--au:0-->Hello World</div>'
 * ```
 */
export async function renderToString(
  definition: ComponentDefinition,
  options: RenderOptions,
): Promise<RenderResult> {
  // Create server platform
  const platform = createServerPlatform();
  const doc = getDocument(platform);

  // Create SSR context with recording capabilities
  const ssrContext = new SSRContext();
  // Set the root template target count so nested views don't collide with root targets
  // The instruction array length equals the number of targets in the root template
  ssrContext.setRootTargetCount(definition.instructions.length);

  // Create DI container with platform and SSR context
  const container = DI.createContainer();
  container.register(
    StandardConfiguration,
    Registration.instance(IPlatform, platform),
    // Register SSR context with recording capabilities
    Registration.instance(ISSRContextToken, ssrContext),
  );

  // Create template element
  const templateEl = doc.createElement("template");
  templateEl.innerHTML = definition.template;

  // Create component class with $au definition
  const componentName = definition.name ?? "ssr-root";
  const Component = class {
    static $au = {
      type: "custom-element" as const,
      name: componentName,
      template: templateEl,
      instructions: definition.instructions,
      needsCompile: false,
    };
  };

  // Apply state to component prototype so instances get those values
  const stateDescriptors: PropertyDescriptorMap = {};
  for (const [key, value] of Object.entries(options.state)) {
    stateDescriptors[key] = { value, writable: true, enumerable: true, configurable: true };
  }
  Object.defineProperties(Component.prototype, stateDescriptors);

  // Create host element
  const host = doc.createElement("div");
  doc.body.appendChild(host);

  // Create and start Aurelia
  const au = new Aurelia(container);
  au.app({ host, component: Component });
  await au.start();

  // Sync DOM properties to attributes for proper HTML serialization
  // (e.g., checkbox.checked=true → <input checked>, input.value → value attr)
  syncPropertiesForSSR(host);

  // Get manifest from SSR context (recorded during rendering)
  const runtimeManifest = ssrContext.getManifest();

  // Process SSR output if options provided
  let result: RenderResult;

  if (options.ssr) {
    // Use the runtime-recorded manifest instead of pre-generated one
    const processed = processSSROutput(host, runtimeManifest, options.ssr);
    result = {
      html: processed.html,
      manifest: processed.manifest,
    };
  } else {
    result = {
      html: host.innerHTML,
      manifest: runtimeManifest,
    };
  }

  // Cleanup
  await au.stop(true);

  return result;
}

/**
 * Options for rendering with real component classes.
 */
export interface RenderWithComponentsOptions {
  /**
   * Child component classes to register in the container.
   * These should already have their $au patched with AOT output.
   */
  childComponents?: ComponentClass[];

  /**
   * SSR processing options.
   */
  ssr?: SSRProcessOptions;
}

/**
 * A component class with a static $au definition.
 * Re-exported from patch.ts for convenience.
 */
export interface ComponentClass {
  new (...args: unknown[]): object;
  $au?: {
    type?: string;
    name?: string;
    template?: unknown;
    instructions?: unknown[][];
    needsCompile?: boolean;
    [key: string]: unknown;
  };
  readonly name: string;
}

/**
 * Render using real component classes with child component support.
 *
 * This function is designed for SSR with real component classes loaded
 * via Vite's ssrLoadModule. Unlike renderToString, it:
 * - Uses real component classes (with getters, methods, constructor logic)
 * - Registers child components in the container
 * - Does NOT apply state (components use their default values)
 *
 * @param RootComponent - The root component class (should have $au patched)
 * @param options - Render options
 * @returns The rendered HTML and manifest
 *
 * @example
 * ```typescript
 * // Load and patch components
 * const { MyApp } = await vite.ssrLoadModule('/src/my-app.ts');
 * const { GreetingCard } = await vite.ssrLoadModule('/src/greeting-card.ts');
 * patchComponentDefinition(MyApp, myAppAot);
 * patchComponentDefinition(GreetingCard, greetingCardAot);
 *
 * // Render
 * const result = await renderWithComponents(MyApp, {
 *   childComponents: [GreetingCard],
 * });
 * ```
 */
export async function renderWithComponents(
  RootComponent: ComponentClass,
  options: RenderWithComponentsOptions = {},
): Promise<RenderResult> {
  // Create server platform
  const platform = createServerPlatform();
  const doc = getDocument(platform);

  // Clear cached definitions for all components BEFORE rendering
  // This is critical for SSR: the runtime caches definitions on the Type,
  // and we need fresh definitions each render to match the patched $au
  CustomElement.clearDefinition(RootComponent);
  if (options.childComponents) {
    for (const ChildComponent of options.childComponents) {
      CustomElement.clearDefinition(ChildComponent);
    }
  }


  // Get root target count from $au definition
  const rootInstructions = RootComponent.$au?.instructions;
  const rootTargetCount = Array.isArray(rootInstructions) ? rootInstructions.length : 0;

  // Create SSR context with recording capabilities
  const ssrContext = new SSRContext();
  ssrContext.setRootTargetCount(rootTargetCount);

  // Create DI container with platform and SSR context
  const container = DI.createContainer();
  container.register(
    StandardConfiguration,
    Registration.instance(IPlatform, platform),
    Registration.instance(ISSRContextToken, ssrContext),
  );

  // Register child components
  if (options.childComponents) {
    for (const ChildComponent of options.childComponents) {
      container.register(ChildComponent);
    }
  }

  // Create host element
  const host = doc.createElement("div");
  doc.body.appendChild(host);

  // Create and start Aurelia with the real component class
  const au = new Aurelia(container);
  au.app({ host, component: RootComponent });
  await au.start();

  // Sync DOM properties to attributes for proper HTML serialization
  // (e.g., checkbox.checked=true → <input checked>, input.value → value attr)
  syncPropertiesForSSR(host);

  // Get manifest from SSR context (recorded during rendering)
  const runtimeManifest = ssrContext.getManifest();

  // Process SSR output if options provided
  let result: RenderResult;

  if (options.ssr) {
    const processed = processSSROutput(host, runtimeManifest, options.ssr);
    result = {
      html: processed.html,
      manifest: processed.manifest,
    };
  } else {
    result = {
      html: host.innerHTML,
      manifest: runtimeManifest,
    };
  }

  // Cleanup
  await au.stop(true);

  return result;
}

/**
 * Render a pre-defined custom element to HTML.
 *
 * Use this when you have a component class that's already defined
 * with the @customElement decorator or static $au property.
 */
export async function renderComponent<T extends object>(
  Component: new () => T,
  options: RenderOptions,
): Promise<RenderResult> {
  // Create server platform
  const platform = createServerPlatform();
  const doc = getDocument(platform);

  // Create SSR context with recording capabilities
  const ssrContext = new SSRContext();

  // Create DI container with platform and SSR context
  const container = DI.createContainer();
  container.register(
    StandardConfiguration,
    Registration.instance(IPlatform, platform),
    // Register SSR context with recording capabilities
    Registration.instance(ISSRContextToken, ssrContext),
  );

  // Apply state to a new instance
  const instance = new Component();
  Object.assign(instance, options.state);

  // Create host element
  const host = doc.createElement("div");
  doc.body.appendChild(host);

  // Create and start Aurelia
  const au = new Aurelia(container);
  au.app({ host, component: instance });
  await au.start();

  // Sync DOM properties to attributes for proper HTML serialization
  // (e.g., checkbox.checked=true → <input checked>, input.value → value attr)
  syncPropertiesForSSR(host);

  // Get manifest from SSR context (recorded during rendering)
  const runtimeManifest = ssrContext.getManifest();

  // Process SSR output if options provided
  let result: RenderResult;

  if (options.ssr) {
    // Use the runtime-recorded manifest instead of pre-generated one
    const processed = processSSROutput(host, runtimeManifest, options.ssr);
    result = {
      html: processed.html,
      manifest: processed.manifest,
    };
  } else {
    result = {
      html: host.innerHTML,
      manifest: runtimeManifest,
    };
  }

  // Cleanup
  await au.stop(true);

  return result;
}
