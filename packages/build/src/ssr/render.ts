/**
 * SSR Renderer
 *
 * Renders Aurelia templates to HTML string using the actual Aurelia runtime.
 * This ensures perfect parity with client-side rendering.
 */

import { DI, Registration } from "@aurelia/kernel";
import { Aurelia, IPlatform, StandardConfiguration, ISSRContextToken, SSRContext } from "@aurelia/runtime-html";
import type { IInstruction } from "@aurelia/template-compiler";
import { createServerPlatform, getDocument } from "./platform.js";
import {
  processSSROutput,
  type HydrationManifest,
  type SSRProcessOptions,
} from "./ssr-processor.js";

export interface RenderOptions {
  /** Component state */
  state: Record<string, unknown>;

  /**
   * SSR processing options.
   * When provided, enables post-render processing for clean HTML output.
   * The manifest is automatically generated by the runtime during rendering
   * via the SSRContext recording mechanism.
   */
  ssr?: SSRProcessOptions;
}

export interface RenderResult {
  /** Rendered HTML (clean if ssr.stripMarkers=true) */
  html: string;

  /**
   * Hydration manifest (with elementPaths if ssr.stripMarkers=true).
   * Only present when ssr options are provided.
   */
  manifest?: HydrationManifest;
}

export interface ComponentDefinition {
  /** Template HTML string */
  template: string;
  /** Binding instructions for the template */
  instructions: IInstruction[][];
  /** Component name */
  name?: string;
}

/**
 * Render a component to HTML string using the Aurelia runtime.
 *
 * @param definition - The compiled component definition
 * @param options - Render options including state
 * @returns The rendered HTML
 *
 * @example
 * ```typescript
 * const result = await renderToString(
 *   {
 *     template: '<div><!--au:0--></div>',
 *     instructions: [[new TextBindingInstruction('message')]],
 *   },
 *   { state: { message: 'Hello World' } }
 * );
 * console.log(result.html); // '<div><!--au:0-->Hello World</div>'
 * ```
 */
export async function renderToString(
  definition: ComponentDefinition,
  options: RenderOptions,
): Promise<RenderResult> {
  // Create server platform
  const platform = createServerPlatform();
  const doc = getDocument(platform);

  // Create SSR context with recording capabilities
  const ssrContext = new SSRContext();

  // Create DI container with platform and SSR context
  const container = DI.createContainer();
  container.register(
    StandardConfiguration,
    Registration.instance(IPlatform, platform),
    // Register SSR context with recording capabilities
    Registration.instance(ISSRContextToken, ssrContext),
  );

  // Create template element
  const templateEl = doc.createElement("template");
  templateEl.innerHTML = definition.template;

  // Create component class with $au definition
  const componentName = definition.name ?? "ssr-root";
  const Component = class {
    static $au = {
      type: "custom-element" as const,
      name: componentName,
      template: templateEl,
      instructions: definition.instructions,
      needsCompile: false,
    };
  };

  // Apply state to component prototype so instances get those values
  const stateDescriptors: PropertyDescriptorMap = {};
  for (const [key, value] of Object.entries(options.state)) {
    stateDescriptors[key] = { value, writable: true, enumerable: true, configurable: true };
  }
  Object.defineProperties(Component.prototype, stateDescriptors);

  // Create host element
  const host = doc.createElement("div");
  doc.body.appendChild(host);

  // Create and start Aurelia
  const au = new Aurelia(container);
  au.app({ host, component: Component });
  await au.start();

  // Get manifest from SSR context (recorded during rendering)
  const runtimeManifest = ssrContext.getManifest();

  // Process SSR output if options provided
  let result: RenderResult;

  if (options.ssr) {
    // Use the runtime-recorded manifest instead of pre-generated one
    const processed = processSSROutput(host, runtimeManifest, options.ssr);
    result = {
      html: processed.html,
      manifest: processed.manifest,
    };
  } else {
    result = {
      html: host.innerHTML,
      manifest: runtimeManifest,
    };
  }

  // Cleanup
  await au.stop(true);

  return result;
}

/**
 * Render a pre-defined custom element to HTML.
 *
 * Use this when you have a component class that's already defined
 * with the @customElement decorator or static $au property.
 */
export async function renderComponent<T extends object>(
  Component: new () => T,
  options: RenderOptions,
): Promise<RenderResult> {
  // Create server platform
  const platform = createServerPlatform();
  const doc = getDocument(platform);

  // Create SSR context with recording capabilities
  const ssrContext = new SSRContext();

  // Create DI container with platform and SSR context
  const container = DI.createContainer();
  container.register(
    StandardConfiguration,
    Registration.instance(IPlatform, platform),
    // Register SSR context with recording capabilities
    Registration.instance(ISSRContextToken, ssrContext),
  );

  // Apply state to a new instance
  const instance = new Component();
  Object.assign(instance, options.state);

  // Create host element
  const host = doc.createElement("div");
  doc.body.appendChild(host);

  // Create and start Aurelia
  const au = new Aurelia(container);
  au.app({ host, component: instance });
  await au.start();

  // Get manifest from SSR context (recorded during rendering)
  const runtimeManifest = ssrContext.getManifest();

  // Process SSR output if options provided
  let result: RenderResult;

  if (options.ssr) {
    // Use the runtime-recorded manifest instead of pre-generated one
    const processed = processSSROutput(host, runtimeManifest, options.ssr);
    result = {
      html: processed.html,
      manifest: processed.manifest,
    };
  } else {
    result = {
      html: host.innerHTML,
      manifest: runtimeManifest,
    };
  }

  // Cleanup
  await au.stop(true);

  return result;
}
