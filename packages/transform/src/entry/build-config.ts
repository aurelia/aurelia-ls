/**
 * AotConfiguration Builder
 *
 * Dynamically constructs AotConfiguration code based on analysis.
 * This replaces StandardConfiguration with a minimal configuration
 * that excludes ExpressionParser and TemplateCompiler for tree-shaking.
 */

import type {
  ConfigBuildOptions,
  ConfigBuildResult,
  RequiredImport,
} from "./types.js";

/**
 * Base registrations that are always needed for AOT.
 *
 * NOTE: ExpressionParser and TemplateCompiler are included for compatibility
 * with third-party libraries that use runtime compilation. Your app's templates
 * are still AOT-compiled for faster initial render.
 *
 * Future: AOT-compile third-party dependencies to enable full tree-shaking.
 */
const BASE_REGISTRATIONS = [
  // Observation infrastructure
  "DirtyChecker",
  "NodeObserverLocator",
  // Runtime compilation - needed by third-party libs
  "ExpressionParser",
  "TemplateCompiler",
  // Built-in resources (if, repeat, etc.)
  "...DefaultResources",
  // Attribute patterns
  "...DefaultBindingSyntax",
  // Binding commands
  "...DefaultBindingLanguage",
  // Renderers for pre-compiled instructions
  "...DefaultRenderers",
] as const;

/**
 * Imports required for the base AOT configuration.
 */
const BASE_IMPORTS: RequiredImport[] = [
  {
    source: "@aurelia/kernel",
    specifiers: ["DI", "Registration"],
  },
  {
    source: "@aurelia/runtime",
    specifiers: ["DirtyChecker"],
  },
  {
    source: "@aurelia/expression-parser",
    specifiers: ["ExpressionParser"],
  },
  {
    source: "@aurelia/template-compiler",
    specifiers: ["TemplateCompiler"],
  },
  {
    source: "@aurelia/runtime-html",
    specifiers: [
      "Aurelia",
      "IPlatform",
      "NodeObserverLocator",
      "DefaultResources",
      "DefaultBindingSyntax",
      "DefaultBindingLanguage",
      "DefaultRenderers",
    ],
  },
  {
    source: "@aurelia/platform-browser",
    specifiers: ["BrowserPlatform"],
  },
];

/**
 * Build AotConfiguration code.
 */
export function buildAotConfiguration(
  options: ConfigBuildOptions = { preservedRegistrations: [] }
): ConfigBuildResult {
  const {
    preservedRegistrations = [],
    indent = "  ",
    includeComments = true,
  } = options;

  const lines: string[] = [];

  // Configuration object
  if (includeComments) {
    lines.push("/**");
    lines.push(" * AOT Configuration - excludes parser/compiler for tree-shaking.");
    lines.push(" * Generated by @aurelia-ls/transform");
    lines.push(" */");
  }

  lines.push("const AotConfiguration = {");
  lines.push(`${indent}register(container) {`);
  lines.push(`${indent}${indent}return container.register(`);

  // Add base registrations
  for (const reg of BASE_REGISTRATIONS) {
    lines.push(`${indent}${indent}${indent}${reg},`);
  }

  lines.push(`${indent}${indent});`);
  lines.push(`${indent}},`);
  lines.push("};");
  lines.push("");

  // Factory function
  if (includeComments) {
    lines.push("/**");
    lines.push(" * Create an Aurelia instance configured for AOT.");
    lines.push(" */");
  }

  lines.push("function createAotAurelia() {");
  lines.push(`${indent}const platform = BrowserPlatform.getOrCreate(globalThis);`);
  lines.push(`${indent}const container = DI.createContainer().register(`);
  lines.push(`${indent}${indent}Registration.instance(IPlatform, platform),`);
  lines.push(`${indent}${indent}AotConfiguration,`);
  lines.push(`${indent});`);
  lines.push(`${indent}return new Aurelia(container);`);
  lines.push("}");

  // Collect required imports
  const requiredImports = [...BASE_IMPORTS];

  // Add imports for preserved registrations if they're known configs
  for (const reg of preservedRegistrations) {
    const importInfo = getImportSourceForRegistration(reg);
    if (importInfo) {
      // Check if we already have this import
      const existing = requiredImports.find((i) => i.source === importInfo.source);
      if (existing) {
        if (!existing.specifiers.includes(importInfo.identifier)) {
          existing.specifiers.push(importInfo.identifier);
        }
      } else {
        requiredImports.push({
          source: importInfo.source,
          specifiers: [importInfo.identifier],
        });
      }
    }
  }

  return {
    code: lines.join("\n"),
    requiredImports,
    configVarName: "AotConfiguration",
    factoryFnName: "createAotAurelia",
  };
}

/**
 * Generate import statements for the configuration.
 */
export function generateImportStatements(
  imports: RequiredImport[],
  existingImports?: Map<string, Set<string>>
): string {
  const lines: string[] = [];

  for (const imp of imports) {
    // Filter out specifiers that are already imported
    let specifiers = imp.specifiers;
    if (existingImports) {
      const existing = existingImports.get(imp.source);
      if (existing) {
        specifiers = specifiers.filter((s) => !existing.has(s));
      }
    }

    if (specifiers.length === 0) continue;

    const specifierStr = specifiers.join(", ");
    if (imp.isType) {
      lines.push(`import type { ${specifierStr} } from "${imp.source}";`);
    } else {
      lines.push(`import { ${specifierStr} } from "${imp.source}";`);
    }
  }

  return lines.join("\n");
}

/**
 * Known configuration import mappings.
 */
const CONFIGURATION_IMPORTS: Record<string, string> = {
  RouterConfiguration: "@aurelia/router",
  DialogConfiguration: "@aurelia/dialog",
  ValidationConfiguration: "@aurelia/validation",
  ValidationHtmlConfiguration: "@aurelia/validation-html",
  I18nConfiguration: "@aurelia/i18n",
  StateConfiguration: "@aurelia/state",
  StateDefaultConfiguration: "@aurelia/state",
  StoreConfiguration: "@aurelia/store-v1",
};

/**
 * Extract the base identifier from a registration expression.
 * Handles both simple identifiers and method calls like `RouterConfiguration.customize(...)`.
 */
function extractBaseIdentifier(expression: string): string | null {
  // Match identifier at the start, optionally followed by .method(...) or (...)
  const match = expression.match(/^([A-Z][a-zA-Z0-9]*)/);
  return match?.[1] ?? null;
}

/**
 * Get the import source for a known registration.
 * Handles both bare identifiers and method call expressions.
 */
function getImportSourceForRegistration(expression: string): { source: string; identifier: string } | null {
  const identifier = extractBaseIdentifier(expression);
  if (!identifier) return null;

  const source = CONFIGURATION_IMPORTS[identifier];
  if (!source) return null;

  return { source, identifier };
}

/**
 * Generate the full initialization code.
 */
export function generateInitialization(options: {
  component: string;
  host?: string;
  preservedRegistrations: string[];
  startMethod?: "start" | "waitForIdle";
}): string {
  const { component, host, preservedRegistrations, startMethod = "start" } = options;

  const lines: string[] = [];

  // Build the chain
  lines.push("createAotAurelia()");

  // Add preserved registrations
  if (preservedRegistrations.length > 0) {
    lines.push(`  .register(${preservedRegistrations.join(", ")})`);
  }

  // App configuration
  if (host) {
    lines.push(`  .app({ host: ${host}, component: ${component} })`);
  } else {
    lines.push(`  .app({ host: document.body, component: ${component} })`);
  }

  // Start
  lines.push(`  .${startMethod}();`);

  return lines.join("\n");
}

/**
 * Generate complete entry point replacement code.
 */
export function generateEntryPointCode(options: {
  component: string;
  host?: string;
  preservedRegistrations: string[];
  otherImports?: string[];
  componentImport?: string;
  includeComments?: boolean;
}): string {
  const {
    component,
    host,
    preservedRegistrations,
    otherImports = [],
    componentImport,
    includeComments = true,
  } = options;

  const configResult = buildAotConfiguration({
    preservedRegistrations,
    includeComments,
  });

  const lines: string[] = [];

  // Imports
  lines.push(generateImportStatements(configResult.requiredImports));

  // Component import
  if (componentImport) {
    lines.push(componentImport);
  }

  // Other imports (preserved from original)
  for (const imp of otherImports) {
    lines.push(imp);
  }

  lines.push("");

  // Configuration and factory
  lines.push(configResult.code);
  lines.push("");

  // Initialization
  lines.push(
    generateInitialization({
      component,
      host,
      preservedRegistrations,
    })
  );

  return lines.join("\n");
}
